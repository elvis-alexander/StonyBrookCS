
// imports
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class TreeNavigator {
    // class fields
    private TreeNode root;
    private TreeNode cursor;
    // global flags
    private static final int POSITION = 0;
    private static final int KEY_WORDS = 1;
    private static final int LEAF_FLAG = 2;
    // leaf detectors
    private static final String LEAF = "leaf";
    private static final String NON_LEAF = "nonleaf";
    // path
    private static final String NOT_CONTAINS = "0";
    private static final String CONTAINS = "1";

    public TreeNavigator() {
        this.root = new TreeNode("tree is empty");
        this.cursor = root;
    }

    public static void main(String[] args) throws Exception {
        TreeNavigator t = TreeNavigator.buildTree("t1.txt");
    }

    /*  Reads in a text file describing a TreeNavigator. See sample input for an example.
        Preconditions: treeFile is a non-null, non-empty String that points to a file that exists that is readable and valid.
        Returns a new TreeNavigator generated by the passed in text file.*/
    public static TreeNavigator buildTree(String treeFile) throws Exception {
        // new tree
        TreeNavigator tree = new TreeNavigator();
        // file stream
        FileInputStream in = new FileInputStream(treeFile);
        // buffered reader
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        // string line
        String strLine = null;
        TreeNode t = null;
        // build tree
        while ((strLine = reader.readLine()) != null)   {
            String[] tree_info = strLine.split(";");
            // if(tree_info[LEAF_FLAG].equals(NON_LEAF)) {
            // new node is a non leaf
            TreeNode newNode = new TreeNode(Arrays.asList(tree_info[KEY_WORDS].split(",")));
            String[] path = tree_info[POSITION].split("-");
            if(path.length == 1) {
                tree.root = newNode;
                tree.cursor = newNode;
                continue;
            }
            // insert into root for root = null
            // non root node ~ find parent of where to place and then set left or right
            TreeNode parent = tree.root;
            for(int i = 1; i < path.length - 1; ++i) {
                if(path[i].equals(NOT_CONTAINS)) {
                    // search left
                    parent = parent.getLeft();
                } else {
                    // search right
                    parent = parent.getRight();
                }
            }
            if(path[path.length-1].equals(NOT_CONTAINS)) {
                // if this does not contain set left child
                parent.setLeft(newNode);
            } else {
                // if this does
                parent.setRight(newNode);
            }
        }
        tree.containsDest(tree.root, t);
        // Close the input stream
        reader.close();
        return tree;
    }

    /*  public String classify(String text)
        Classifies the text with the given tree and returns the classification as a String.
        public String getPath()
        Gets the current path of the cursor. For example, if cursor referred to a TreeNode at position “Garfield” in the example below, this method should return “NOT red, NOT coyote,wolf, IS cat, IS orange, DECISION: Garfield”
        Note the comma above: This is how you can show multiple keywords.*/

     /*Gets the current path of the cursor. For example, if cursor referred to a TreeNode at position “Garfield”
     in the example below, this method should return “NOT red, NOT coyote,wolf, IS cat, IS orange, DECISION: Garfield”*/
    public String getPath() {
        return null;
    }

    public static boolean containsDest(TreeNode root, TreeNode dest){
        if (root == null) {
            return false;
        } else if(root == dest) {
            return true;
        } else if(containsDest(root.getLeft(), dest)) {
            System.out.print("NOT: ");
            System.out.print(root.display() + ", ");
            return true;
        } else if(containsDest(root.getRight(), dest)) {
            System.out.print("IS: ");
            System.out.print(root.display() + ", ");
            return true;
        }
        return false;
    }
//    NOT red, NOT coyote,wolf, IS cat, IS orange, DECISION: Garfield

    /* returns parent node of a given node n */
    public TreeNode getParent(TreeNode curr, TreeNode n) {
        if(curr == null)
            return null;
        if(curr.getLeft() == n || curr.getRight() == n) {
            return curr;
        }

        TreeNode t1 = getParent(curr.getLeft(), n);
        if(t1 != null)
            return t1;
        else
            return getParent(curr.getRight(), n);
    }

    /* Resets the cursor to the root node. */
    public void resetCursor() {
        this.cursor = this.root;
    }

    /*  Moves cursor to its left child. */
    public void cursorLeft() {
        if(cursor != null) {
            this.cursor = this.cursor.getLeft();
        }
    }

    /* move cursor to right child */
    public void cursorRight() {
        if(cursor != null) {
            this.cursor = this.cursor.getRight();
        }
    }

    /* this gets the root of tree */
    public TreeNode getRoot() { return this.root; }

    /* sets cursor */
    public void setCursor(TreeNode c) { this.cursor = c; }

    /* This gets the Cursor so you can modify the keywords or the Left or the Right child links. */
    public TreeNode getCursor() {
        return this.cursor;
    }

    /* Sets the keywords for the current cursor */
    public void editCursor(String text) { this.cursor.setKeywords(Arrays.asList(text.split(","))); }

    /* helper to print cursor */
    public void printCursor() {
        // see sample I/O
        /* Cursor moved. Cursor is at leaf, message is 'tempYes'. */
        System.out.println(String.format("Cursor moved. Cursor is at leaf, message is '%s'", cursor.firstKey()));
    }
}